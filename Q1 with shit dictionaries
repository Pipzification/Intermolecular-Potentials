'''
Intermolecular Potentials 2023
Candidate Number: 1538669
Date: 26/4/23
Dependencies: Python 3.9.1
'''

# Imports the required modules

import numpy as np

# Set the constants (for water)

r = 2.5                                      # Distance (Å)
static = 1.8550                              # Static dipole (Debye)
a = 1.4500                                   # Dipole polarisability (/4pi*vacuum permittivity) (Å^3)
E0 = 0.005526349406                          # Vacuum permittivity (e^2 eV^-1 Å^-1)

# Opens the required lists and dictionaries

distances = {}            # Dictionary storing the distances between the molecules
mol_list = []             # List of the names of the molecules
induced = {}              # Dictionary for forces
total_induced = {}        # Dictionary for total induced dipole
induction_energy = {}     # Dictionary for induction energy

for j in range(0, 5):

    # Calculates the distances and fills distances dictionary

    r_list = []
    molecule = "molecule{}".format(j)
    mol_list.append(molecule)
    distances["molecule{}".format(j)] = []

    r0 = abs(0 - j * r)
    r1 = abs(r - j * r)
    r2 = abs(2 * r - j * r)
    r3 = abs(3 * r - j * r)
    r4 = abs(4 * r - j * r)

    r_list.extend((r0, r1, r2, r3, r4))

    distances["molecule{}".format(j)].append(r_list)


# The while loop for the iteration

u_total = static
Dipole1 = 0
Dipole = 1

while Dipole1 != Dipole:

    Dipole = Dipole1

    for i in range(0, 5):

        # Calculates the induced dipole for each molecule

        induced["molecule{}".format(i)] = []
        total_induced["molecule{}".format(i)] = []
        induction_energy["molecule{}".format(i)] = []
        molec = "molecule{}".format(i)

        id_list = []
        ide_list = []

        for molec in distances:

            InducedDipole = (2 * a * u_total) / (r**3)
            id_list.append(InducedDipole)
            induced_energy = (2 * a * ((u_total)**2)) / (4 * np.pi * E0 * (r**6))
            ide_list.append(induced_energy)

        induced["molecule{}".format(i)].append(id_list)
        total_ide = 0.5 * (np.sum(ide_list))
        total_ind = np.sum(id_list)
        total_induced["molecule{}".format(i)].append(total_ind)
        induction_energy["molecule{}".format(i)].append(total_ide)

    total_dipole = u_total + (np.sum(total_induced.values()))
    total_induction_energy = np.sum(induction_energy.values())
    u_total = total_dipole
    print(total_induction_energy, 'eV Å⁻¹')
    Dipole1 = round(total_dipole, 5)

else:
    print('For distance', r)
    print('Final total dipole', Dipole1, 'D')
    print('Final Total Induction Energy:', total_induction_energy, 'eV Å⁻¹' )


